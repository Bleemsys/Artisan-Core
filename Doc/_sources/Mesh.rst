Mesh Lattice
************

You might want to generate mesh-like conformal lattice. For example, a STL model actually contains many triangles that forms the geometry, these triangle surfaces can be converted to a set of lattice. It is very easy to proceed the conversion using Artisan, if user have the mesh file.

Artisan supports the conversion of line, triangles and tetrahedron elements. Similar to the customized lattice definition, we only need change the parameter :code:`la_name` to the path of the file which provides the mesh definition. 

For example, we have the following main JSON file which fills a part with tetrahedron mesh. The mesh could be generated by an external mesher, such as Gmsh, Salome etc.. 

.. code-block:: json

    {"Setup":{  "Type" : "Geometry",
                "Geomfile": ".//sample-obj//Parts01//Parts01.stl",
                "Rot" : [0.0,0.0,0.0],
                "res":[0.25,0.25,0.25],
                "Padding": 2,
                "onGPU": false,
                "memorylimit": 16106127360
                },
     "WorkFlow":{
          "1": {"Add_Lattice":{
                    "la_name": ".//Test_json//Parts01_Mesh_Infill_LR.mld", 
                    "size": [4.0,4.0,4.0], "thk":0.3, "Rot":[0.0, 0.0, 0.0], "Trans":[0.0, 0.0, 0.0],
                    "Inv": false, "Fill": false, 
                    "Cube_Request": {}
                    }
               },
          "2":{"Export": {"outfile": ".//Test_results/Parts01_Mesh_Infill.stl"}}
           },
     "PostProcess":{"CombineMeshes": true,
                "RemovePartitionMeshFile": false,
                "RemoveIsolatedParts": false, 
                "ExportLazPts": false}
    }

You might notice that the parameter :code:`Padding` became 2, it is different from previous examples's value 1. The padding meant the additional number of resolution grids padding around the given geometry domain, i.e. the bounding box. In this case, if we do not apply fill operation, that cuts the lattice by using the geometry shape, we should consider add padding grids for the boundary lattice integrity. The lattice definition points to the file :code:`.//Test_json//Parts01_Mesh_Infill_LR.mld`. The extension mld stands for mesh lattice definition. The mld file defines mesh file.

.. code-block:: json

    {
     "type": "MeshLattice",
     "definition": {
          "meshfile": ".//sample-obj//Parts01//Parts01.med",
      }
    }

As stated above, the mesh file points to :code:`.//sample-obj//Parts01//Parts01.med` and type of filling is called :code:`MeshLattice`. Artisan currently supports the following mesh file format:

.. list-table:: 
   :widths: 30 30 40
   :header-rows: 1

   * - File extension
     - Original software
     - Supporting element types
   * - :code:`.med`
     - Salome platform
     - Beam, Tet, Hex,
   * - :code:`.msh` 
     - Ansys Mesh Export (Fluent Mesh Export Option)
     - Beam, Tet
   * - :code:`.inp`
     - Abaqus input file
     - Beam, Tet, Hex
   * - :code:`.bdf`
     - Nastran
     - Beam, Tet, Hex
   * - :code:`.stl`, :code:`.obj`, :code:`.ply`
     - Geometry file format
     - Triangle


The result is shown below. 

.. image:: ./pictures/MeshLattice.png

One notes that, the parameter of :code:`size` in the keywords :code:`Add_Lattice` influences the computing performance. Ideally, this parameter shall define approximated size of a single tetrahedron element. In the some cases of mixed size of elements, user may consider use the smallest element size. Bigger or smaller size definition could yield longer computational time. 

User could certainly combine the mesh lattice with other types of lattice, such as periodic lattice. For example, the example below showed a simple combination of Cubic lattice and mesh lattice. Below is an example main JSON that combines the cubic lattice with mesh lattice. Other interpolation keywords, such as :code:`Lin_Interpolate` and :code:`Attractor`, are also supported. 

.. code-block:: json

    {"Setup":{  "Type" : "Geometry",
                "Geomfile": ".//sample-obj//Parts02//Parts02.stl",
                "Rot" : [0.0,0.0,0.0],
                "res":[0.8,0.8,0.8],
		        "Padding": 3,
                "onGPU": false,
                "memorylimit": 16106127360
                },
     "WorkFlow":{
          "1": {"Add_Lattice":{
                    "la_name": "Cubic", "size": [10.0,10.0,10.0], "thk":1.5, "Rot":[0.0, 0.0, 0.0], "Trans":[0.0, 0.0, 0.0],
                    "Inv": false, "Fill": true, "Cube_Request": {}
                    }
               },
          "2" :{"HS_Interpolate" : {
                    "la_name": ".//Test_json//Parts02_Mesh_Infill_LR.mld", 
                    "size": [4.0,4.0,4.0], 
                    "thk": 1.5, "pt":[0.0,0.0,0.0], 
                    "n_vec":[-1.0,0.0,0.0], "Fill": false, "Cube_Request": {}
                    }},
          "3":{"Export": {"outfile": ".//Test_results/Parts02_Combined_Infill.stl"}}
           },
     "PostProcess":{"CombineMeshes": true,
                "RemovePartitionMeshFile": false,
                "RemoveIsolatedParts": true, 
                "ExportLazPts": false}
    }

We have a half-half infill. 

.. image:: ./pictures/MeshLattice_Combined.png

